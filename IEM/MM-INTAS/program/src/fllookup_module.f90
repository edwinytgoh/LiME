!#0  subroutine init_fllookup_files

! Initialisation routines
!#1  subroutine luinit
!#2  subroutine get_index_depprop
!#3  subroutine rdfldata (called by 'luinit')

! Look-up routines
!#4  subroutine ppropv
!#5  subroutine phy2yv (called by 'ppropv')
!#6  subroutine lookupv (called by 'ppropv')


!=======================================================================
!=======================================================================
!
!  THIS MODULE CAN BE USED TO RETRIEVE INFORMATION FROM LOOK-UP DATA
!  FILES GENERATED BY THE COMPUTER PROGRAM 'FLAME' BY T.W.J. PEETERS
!
!=======================================================================
!=======================================================================


      MODULE fllookup_module

      USE cmn_param, ONLY : zero, one, fileln


!=======================================================================
!
!     LOOKUP TABLE WORKSPACE
!
!     lenilu : dimension of integer work array
!     lenrlu : dimension of real work array
!     lenclu : dimension of character work array
!     iluwrk : integer work array
!     rluwrk : real work array
!     cluwrk : character work array
!-----------------------------------------------------------------------
      INTEGER (KIND=4), SAVE :: lenilu, lenrlu, lenclu
      INTEGER (KIND=4) , ALLOCATABLE, SAVE :: iluwrk(:)       ! (lenilu)
      REAL    (KIND=8) , ALLOCATABLE, SAVE :: rluwrk(:)       ! (lenrlu)
      CHARACTER(LEN=16), ALLOCATABLE, SAVE :: cluwrk(:)       ! (lenclu)

!=======================================================================
!
!     PROBLEM SIZE
!
!     ndim   : actual dimension of lookup table
!     nprop  : actual number of properties stored in lookup table
!     ncornr : number of corner nodes for each cell
!     nnodes : number of nodes stored in lookup table
!     ncells : number of cells stored in lookup table
!     ivf    : pointer for mixture fraction
!-----------------------------------------------------------------------
      INTEGER (KIND=4), SAVE :: ndim, nprop, ncornr, nnodes, ncells, &
                                ivf

!=======================================================================
!
!     DECLARATION OF LOOK-UP TABLE POINTERS
!
!     IwNCRS : pointer to coarse grid structure
!     IwNCHL : pointer to child cell numbers for each cell
!     IwNCRN : pointer to corner node numbers for each cell
!     IwXMIN : pointer to lower limits of independent variables 
!     IwXMAX : pointer to upper limits of independent variables 
!     IwXNOD : pointer to coordinates for each node
!     IwPTAB : pointer to properties for each node
!     IwPNAM : pointer to property names
!     IwPUNI : pointer to property units
!     IwVNAM : pointer to independent-variable names
!     IwVUNI : pointer to independent-variable units
!     itrans : integer flag for transformed computational domain
!-----------------------------------------------------------------------
      INTEGER (KIND=4), SAVE :: IwNCRS,IwNCHL,IwNCRN, &
                                IwXMIN,IwXMAX,IwXNOD,IwPTAB, &
                                IwPNAM,IwPUNI,IwVNAM,IwVUNI, &
                                itrans

!=======================================================================
!
!     MINIMUM / MAXIMUM VALUES
!
!     xmin   : minimum value of physical domain
!     xmax   : maximum value of physical domain
!-----------------------------------------------------------------------
      REAL    (KIND=8), ALLOCATABLE, SAVE :: xmin(:)          ! (ndim)
      REAL    (KIND=8), ALLOCATABLE, SAVE :: xmax(:)          ! (ndim)

                           
!=======================================================================
!
!     VECTORLENGTH
!
!     vectorlength VECLEN should be adjusted to obtain the optimal
!     vectorization of routines ppropv and lookupv
!
!     veclen   : length of array used in lookup
!     critlen  : length of array used routine PPLUCRIT
!
!-----------------------------------------------------------------------

      INTEGER (KIND=4), PARAMETER :: veclen = 2048
      INTEGER (KIND=4), PARAMETER :: critlen = 10 * veclen


!=======================================================================
!
!     FILES
!
!-----------------------------------------------------------------------

!------  Info files

      INTEGER (KIND=4), SAVE :: loutf
      INTEGER (KIND=4), SAVE :: llogf

!------  Look-up files

      INTEGER (KIND=4), SAVE :: ldatf
      CHARACTER(LEN=fileln), SAVE :: datf


      CONTAINS

!#0
!=======================================================================
      SUBROUTINE init_fllookup_files (loutput, llog, lfldat, fldat)
!=======================================================================

      IMPLICIT NONE

!-----  input variables
      INTEGER (KIND=4), INTENT(IN) :: loutput
      INTEGER (KIND=4), INTENT(IN) :: llog
      INTEGER (KIND=4), INTENT(IN) :: lfldat
      CHARACTER(LEN=fileln), INTENT(IN) :: fldat


!-----  MAIN ACTION

      loutf = loutput
      llogf = llog
      ldatf = lfldat    ; datf = fldat

      END SUBROUTINE init_fllookup_files


!======================================================================!
!                                                                      !
!              i n i t i a l i z a t i o n   r o u t i n e             !
!                                                                      !
!======================================================================!


!#1
!=======================================================================
      SUBROUTINE luinit
!=======================================================================
!  Retrieve properties from look-up table.
!-----------------------------------------------------------------------

      IMPLICIT NONE

!-----  local variables
      INTEGER (KIND=4) :: i, fmtdat
      LOGICAL          :: Lexist
      REAL    (KIND=8), PARAMETER :: huge = 1.D40, one = 1.D0

!-----  MAIN ACTION

      !--- the lookup table provided to test the MM-INTAS program
      !    are in ASCII format
      fmtdat = 1

!-----  read table dimensions
      INQUIRE (FILE=datf,EXIST=Lexist)
      IF (.NOT.Lexist) THEN
         WRITE (loutf,'(/A,/A,A,A,/A)') &
            'Error in subroutine LUINIT', &
            'Non-existing lookup datafile : ', TRIM(datf), &
            'Program terminated.'
         STOP
      END IF

      itrans = 0
      IF (fmtdat == 0) THEN
         OPEN (UNIT=ldatf, &
               FILE=datf, &
               FORM='UNFORMATTED', &
               ACCESS='SEQUENTIAL', &
               STATUS='OLD')
         READ (ldatf,ERR=1111) ndim, nnodes, ncells, nprop, itrans
      ELSE
         OPEN (UNIT=ldatf, &
               FILE=datf, &
               FORM='FORMATTED', &
               ACCESS='SEQUENTIAL', &
               STATUS='OLD')
         READ (ldatf,'(5I8)',ERR=1111) ndim, nnodes, ncells, nprop, itrans
      END IF

 1111 CONTINUE
      ncornr = 2**ndim

!-----  set up the pointers for the workspace arrays
      IwNCRS = 1
      IwNCHL = IwNCRS + ndim
      IwNCRN = IwNCHL + ncells
      lenilu = IwNCRN + ncells*ncornr - 1

      IwXMIN = 1
      IwXMAX = IwXMIN + ndim
      IwXNOD = IwXMAX + ndim
      IwPTAB = IwXNOD + ndim *nnodes
      lenrlu = IwPTAB + nprop*nnodes - 1

      IwVNAM = 1
      IwPNAM = IwVNAM + ndim
      IwVUNI = IwPNAM + nprop
      IwPUNI = IwVUNI + ndim
      lenclu = IwPUNI + nprop - 1

      ALLOCATE (iluwrk(lenilu)); iluwrk = 0
      ALLOCATE (rluwrk(lenrlu)); rluwrk = 0.
      ALLOCATE (cluwrk(lenclu)); cluwrk = ' '

      PRINT*,'Allocated ILUWRK; size = ',lenilu
      PRINT*,'Allocated RLUWRK; size = ',lenrlu
      PRINT*,'Allocated CLUWRK; size = ',lenclu

!-----  read table
      CALL rdfldata (fmtdat, &
                     iluwrk(IwNCRS),iluwrk(IwNCHL),iluwrk(IwNCRN), &
                     rluwrk(IwXMIN),rluwrk(IwXMAX), &
                     rluwrk(IwXNOD),rluwrk(IwPTAB), &
                     cluwrk(IwVNAM),cluwrk(IwVUNI), &
                     cluwrk(IwPNAM),cluwrk(IwPUNI))
      CLOSE (ldatf)

!-----  get pointers for f, g, h, yNO and yCO
      ivf    = 0
      DO i = 1, ndim
         IF (cluwrk(IwVNAM+i-1) == 'MIXTURE FRACTION') ivf = i
      END DO

!-----  error messages
      IF (ivf == 0) THEN
         WRITE(loutf,'(/A,/A,/A)') &
            'Error in subroutine LUINIT:', &
            'Mixture fraction or progress variable not a ', &
            'variable in lookup table'
         STOP
      END IF

!-----  reset XMIN and XMAX for transformed domain
      ALLOCATE (xmin(ndim)); xmin = 0.d0
      ALLOCATE (xmax(ndim)); xmax = 0.d0
      DO i = 1, ndim
         xmin(i) = rluwrk(IwXMIN+i-1)
         xmax(i) = rluwrk(IwXMAX+i-1)
      END DO

      IF (itrans == 1) THEN
         DO i = 1, ndim
            rluwrk(IwXMIN+i-1) = 0.d0
            rluwrk(IwXMAX+i-1) = 1.d0
         END DO
      END IF

      END SUBROUTINE luinit


!#2
!=======================================================================
!     subroutine get_index_depprop
!=======================================================================
      SUBROUTINE get_index_depprop(ndepv, name_depprop, index_depprop)

      IMPLICIT NONE

!-----  input variables
      INTEGER (KIND=4), INTENT(IN) :: ndepv
      CHARACTER(LEN=*), INTENT(IN) :: name_depprop(ndepv)

!-----  output variables
      INTEGER (KIND=4), INTENT(OUT) :: index_depprop(ndepv)

!-----  local variables
      INTEGER (KIND=4) :: prop, depprop, nerr


!======  MAIN ACTION

!-----  initialise array
      index_depprop = -1

!-----  search for keywords in lookup CLUWRK-array
      DO prop = 1, nprop
         DO depprop = 1, ndepv
            IF (CLUWRK(IwPNAM+prop-1)(:16) == name_depprop(depprop)(:16)) THEN
               index_depprop(depprop) = prop
            END IF
         END DO
      END DO

!-----  check if all keywords have been found
      nerr = 0
      DO depprop = 1, ndepv
         WRITE(*,*) 'index(', TRIM(name_depprop(depprop)), ') = ', &
           index_depprop(depprop)
         IF (index_depprop(depprop) < 0) THEN
            nerr = nerr + 1
            WRITE(loutf,'(A,/A)') &
              'Property not found in table :', name_depprop(depprop)
         END IF
      END DO
      IF (nerr >= 1) THEN
         WRITE(loutf,'(A)') 'Stopped in routine GET_INDEX_DEPPROP'
         STOP
      END IF

      END SUBROUTINE get_index_depprop


!#3
!=======================================================================
      SUBROUTINE rdfldata (fmtdat,  &
                           ncoars, nchild, ncnode,  &
                           xmin, xmax, xnodes, protab,  &
                           varnam, varuni, pronam, prouni)
!=======================================================================
!  Read tabulated properties from dataset.
!-----------------------------------------------------------------------
!  variables in the argument list:
!
!  i  fmtdat : designator unformatted (0) or formatted (1) datafiles
!  i  ndim   : number of independent variables (problem dimension)
!  i  nnodes : number of grid nodes
!  i  ncells : number of grid cells
!  i  nprop  : number of properties per grid node
!  i  ncornr : number of corner nodes per cell
!
!  o  ncoars : number of initial coarse grid cells
!  o  nchild : cell number of cell's first child cell
!  o  ncornr : node numbers of cell's vertices
!  o  xmin   : lower bounds of independent variables on grid
!  o  xmax   : upper bounds of independent variables on grid
!  o  xnodes : position of grid nodes
!  o  protab : property values at each grid node
!  o  varnam : variable names
!  o  varuni : variable units
!  o  pronam : property names
!  o  prouni : property units
!-----------------------------------------------------------------------

!-----  used modules

      IMPLICIT NONE

!-----  arguments
      INTEGER (KIND=4), INTENT(IN) :: fmtdat

      INTEGER (KIND=4), INTENT(OUT) :: ncoars(*)            ! (ndim)
      INTEGER (KIND=4), INTENT(OUT) :: ncnode(ncornr,*)     ! (ncornr,ncells)
      INTEGER (KIND=4), INTENT(OUT) :: nchild(*)            ! (ncells)

      REAL    (KIND=8), INTENT(OUT) :: xmin(*)              ! (ndim)
      REAL    (KIND=8), INTENT(OUT) :: xmax(*)              ! (ndim)
      REAL    (KIND=8), INTENT(OUT) :: xnodes(ndim,*)       ! (ndim,nnodes)
      REAL    (KIND=8), INTENT(OUT) :: protab(nprop,*)      ! (nprop,nnodes)

      CHARACTER(LEN=*), INTENT(OUT) :: varnam(*)            ! (ndim)
      CHARACTER(LEN=*), INTENT(OUT) :: varuni(*)            ! (ndim)
      CHARACTER(LEN=*), INTENT(OUT) :: pronam(*)            ! (nprop)
      CHARACTER(LEN=*), INTENT(OUT) :: prouni(*)            ! (nprop)

!-----  local variables
      INTEGER(KIND=4) :: i, j

!===== MAIN ACTION

      IF (fmtdat == 0) THEN
         READ (ldatf) (ncoars(i),i=1,ndim)
         READ (ldatf) (nchild(i),i=1,ncells)
         READ (ldatf) ((ncnode(i,j),i=1,ncornr),j=1,ncells)

         READ (ldatf) (xmin(i),i=1,ndim)
         READ (ldatf) (xmax(i),i=1,ndim)
         READ (ldatf) ((xnodes(i,j),i=1,ndim) ,j=1,nnodes)
         READ (ldatf) ((protab(i,j),i=1,nprop),j=1,nnodes)

         READ (ldatf) (varnam(i),i=1,ndim)
         READ (ldatf) (varuni(i),i=1,ndim)
         READ (ldatf) (pronam(i),i=1,nprop)
         READ (ldatf) (prouni(i),i=1,nprop)

      ELSE
         READ (ldatf,'(5I8)')    (ncoars(i),i=1,ndim)
         READ (ldatf,'(10I8)')   (nchild(i),i=1,ncells)
         READ (ldatf,'(10I8)')   ((ncnode(i,j),i=1,ncornr),j=1,ncells)

         READ (ldatf,'(5E16.8)') (xmin(i),i=1,ndim)
         READ (ldatf,'(5E16.8)') (xmax(i),i=1,ndim)
         READ (ldatf,'(5E16.8)') ((xnodes(i,j),i=1,ndim) ,j=1,nnodes)
         READ (ldatf,'(5E16.8)') ((protab(i,j),i=1,nprop),j=1,nnodes)

         READ (ldatf,'(5A16)')   (varnam(i),i=1,ndim)
         READ (ldatf,'(5A16)')   (varuni(i),i=1,ndim)
         READ (ldatf,'(5A16)')   (pronam(i),i=1,nprop)
         READ (ldatf,'(5A16)')   (prouni(i),i=1,nprop)
      END IF

      END SUBROUTINE rdfldata


!======================================================================!
!                                                                      !
!                    l o o k u p   r o u t i n e                       !
!                                                                      !
!======================================================================!


!#4
!=======================================================================
      SUBROUTINE ppropv (npart, npd, nsv, ndv, &
                         index_depprop, prho, &
                         f_kf, f_kdf, f_kvol)
!=======================================================================
!  Serves as an interface between the Monte Carlo PDF code
!  and the lookup procedure.
!-----------------------------------------------------------------------
!  variables in the argument list:
!
!  i  f      : array containing particle properties
!  i  npart  : number of particles for which lookup is performed
!  i  kf     : index to particle property first independent scalar
!  i  kl     : index to particle property last independent scalar
!  i  kvol   : index to particle property specific volume
!  i  npd    : first array dimension f
!
!  o  f      : array containing particle properties
!-----------------------------------------------------------------------

      IMPLICIT NONE

!-----  input variables
      INTEGER (KIND=4), INTENT(IN) :: npart, npd, nsv, ndv
      INTEGER (KIND=4), INTENT(IN) :: prho
      INTEGER (KIND=4), INTENT(IN) :: index_depprop(ndv)
      REAL    (KIND=8), INTENT(IN) :: f_kf(npd,nsv)

!-----  output variables
      REAL    (KIND=8), INTENT(OUT) :: f_kdf(npd,ndv)
      REAL    (KIND=8), INTENT(OUT) :: f_kvol(npart)

!-----  local variables
      INTEGER (KIND=4) :: i, k, l, m, maxi, maxm

      REAL    (KIND=8), ALLOCATABLE :: point(:,:)       ! (maxm, 0:ndim)
      REAL    (KIND=8), ALLOCATABLE :: y(:,:)           ! (maxm, 0:ndim)
      REAL    (KIND=8), ALLOCATABLE :: flprop(:,:)      ! (maxm, nprop)

      REAL    (KIND=8), PARAMETER :: tiny = 1.d-10

!-----  MAIN ACTION

!-----  loop over particles, split into two parts:
!       1. loop over vectors of length veclen (l loop)
!       2. loops over particles in vectors (i and m loops)
      DO l = 1, npart, veclen
         
         !--- calculate maximal values for 
         !     i - overall particle number
         !     m - particle number in vector of length veclen
         maxi = MIN(l + veclen - 1, npart)         
         maxm = maxi  - l + 1

         ALLOCATE (point(maxm, 0:ndim)) ; point = 0.d0
         ALLOCATE (y(maxm, 0:ndim))
         ALLOCATE (flprop(maxm,nprop))


         DO i = l, maxi
            m = i - l + 1

            !--- put independent scalars in array 'point'
            IF (ivf > 0) THEN
                point(m,ivf) = f_kf(i,1)
                point(m,ivf) = MAX(point(m,ivf), tiny)   
                point(m,ivf) = MIN(point(m,ivf), one - tiny)   
            ELSE
               !--- In the test cases provided for the MM-INTAS code,
               !    only one scalar is consider (ndim=1): mixture
               !    fraction. So ivf HAS TO be equal to 1.
               STOP 'PPROPV: This should not happen in MM-INTAS.'
            END IF
         END DO

         !--- transformation from physical domain to mathematical
         !    look-up domain
         CALL phy2yv(point(1,0), maxm, y(1,0))


         !--- INTERPOLATION FROM LOOK-UP TABLE
         !    find dependent scalars in table
         CALL lookupv(iluwrk(IwNCRS),iluwrk(IwNCRN),iluwrk(IwNCHL), &
                      rluwrk(IwXMIN),rluwrk(IwXMAX),rluwrk(IwXNOD), &
                      rluwrk(IwPTAB),y(1,1),flprop,maxm)

         DO i = l, maxi
            m = i - l + 1
            DO k = 1, ndv
               f_kdf(i,k) = flprop(m,index_depprop(k))
            END DO
            f_kvol(i) = 1.d0 / f_kdf(i,prho)
         END DO
    
         DEALLOCATE (point)
         DEALLOCATE (y)
         DEALLOCATE (flprop)

      END DO
!-----  end of main loop over all particles

      END SUBROUTINE ppropv


!#5
!=======================================================================
      SUBROUTINE phy2yv(phy, n, y)
!=======================================================================
!  Transform the physical values to y-values (transformed).
!  Thus, the arbitrarily shaped domain of physically allowed values
!  is mapped onto the (rectangular) computational domain of y-values.
!  This routine is only used for lookup from a previously computed table.
!-----------------------------------------------------------------------
!  Variables in the argument list:
!  i  phy   : coordinates in physical domain
!  i  n     : number of particles
!  o  y     : coordinates in computational domain
!-----------------------------------------------------------------------

      IMPLICIT NONE

!-----  input variables
      INTEGER (KIND=4), INTENT(IN) :: n
      REAL    (KIND=8), INTENT(IN) :: phy(n,0:ndim)

!-----  output variables
      REAL    (KIND=8), INTENT(OUT) :: y(n,0:ndim)

!------  local variables
      INTEGER (KIND=4) :: m, k
      REAL    (KIND=8) :: maxmin

!-----  MAIN ACTION

!-----  no transformation
      DO k = 0, ndim
         DO m = 1, n
            y(m,k) = phy(m,k)
         END DO
      END DO

      IF (itrans == 0) THEN
         RETURN
      END IF

!-----  transformation of mixture fraction
      maxmin = MAX(xmax(ivf) - xmin(ivf), 1.d-30)
      DO m = 1, n
         y(m,ivf) = (phy(m,ivf) - xmin(ivf)) / maxmin
         y(m,ivf) = MIN(1.D0,y(m,ivf))
         y(m,ivf) = MAX(0.D0,y(m,ivf))
      END DO

      END SUBROUTINE phy2yv


!#6
!=======================================================================
      SUBROUTINE lookupv(ncoars,ncnode,nchild, &
                         xmin,xmax,xnodes,protab,point, &
                         prop,npart)
!=======================================================================
!  This subroutine interpolates the property table.
!  For a given set of coordinates the appropriate cell is determined.
!  Multi-linear interpolation is used by employing the tabulated
!  property values at the cell corner nodes.
!-----------------------------------------------------------------------
!  variables in the argument list:
!
!  i  ncoars : number of coarse grid cells in each direction (ndim)
!  i  ncnode : node numbers of cell vertices       (ncornr,ncells)
!  i  nchild : cell number of first child cell     (ncells)
!  i  xmin   : lower bound of computational domain (ndim)
!  i  xmax   : upper bound of computational domain (ndim)
!  i  xnodes : position of nodes (dimension ndim x nnodes)
!  i  protab : values of properties at node positions
!              (dimension nprop x nnodes)
!  i  point  : vector with location of look-up point
!              dimension ndim
!  i  npart  : number of particles for which look-up is requested
!
!  o  prop   : interpolated properties at location 'point'
!-----------------------------------------------------------------------

      IMPLICIT NONE

!-----  input variables
      INTEGER (KIND=4), INTENT(IN) :: npart
      INTEGER (KIND=4), INTENT(IN) :: ncoars(ndim)
      INTEGER (KIND=4), INTENT(IN) :: ncnode(ncornr,ncells)
      INTEGER (KIND=4), INTENT(IN) :: nchild(ncells)

      REAL    (KIND=8), INTENT(IN) :: xmin(ndim)
      REAL    (KIND=8), INTENT(IN) :: xmax(ndim)
      REAL    (KIND=8), INTENT(IN) :: xnodes(ndim,nnodes)
      REAL    (KIND=8), INTENT(IN) :: protab(nprop,nnodes)
      REAL    (KIND=8), INTENT(IN) :: point(npart,ndim)

!-----  output variables
      REAL    (KIND=8), INTENT(OUT) :: prop(npart,nprop)

!-----  local variables
      INTEGER (KIND=4) :: idim, jdim, n, ifac, &
                          jcell, icornr, iside, &
                          idum, iprop, m, tchild
      INTEGER (KIND=4) :: icrs(npart)
      INTEGER (KIND=4) :: icell(npart)
      INTEGER (KIND=4) :: inode(npart)

      REAL    (KIND=8) :: x1, x2, xp, fac1
      REAL    (KIND=8) :: x(npart,4,2)
      REAL    (KIND=8) :: factor(npart)
      REAL    (KIND=8) :: facx(npart,4,0:1)
      REAL    (KIND=8) :: frac(npart)

      LOGICAL    :: Found

      REAL    (KIND=8), PARAMETER :: small = 1.d-10, tiny = 1.d-38

!-----  MAIN ACTION

      ifac  = 1

      !--- initialize icell
      DO m = 1, npart
         icell(m) = 0
      END DO

      !--- loop over dimensions table
      DO n = 1, ndim

         !--- loop over particles 
         DO m = 1, npart
            frac(m)  = (point(m,n) - xmin(n))/(xmax(n) - xmin(n))* &
                       FLOAT(ncoars(n))
            icrs(m)  = INT(frac(m))
            icrs(m)  = MAX(0,icrs(m))
            icrs(m)  = MIN(icrs(m),ncoars(n)-1)
            icell(m) = icell(m) + icrs(m)*ifac
         END DO

         ifac = ifac*ncoars(n)

      END DO

      !--- increment icell(m) by 1
      DO m = 1, npart
         icell(m) = icell(m) + 1
      END DO

      !--- check if any of the cells has child cells
200   CONTINUE
      tchild = 0
      DO m = 1, npart
         tchild = tchild + nchild(icell(m))
      END DO

      IF (tchild == 0) THEN
      !--------------------------------------------
      !  cells have no child cells
      !--------
      !  perform multi-linear interpolation
      !  determine multiplicators for interpolation
      !--------------------------------------------

         !--- initialize dependent properties to zero
         DO iprop = 1,nprop
            DO m = 1, npart
               prop(m,iprop) = zero
            END DO
         END DO

         !--- position of first corner node
         DO m = 1, npart
            inode(m) = ncnode(1,icell(m))
         END DO
         DO idim = 1, ndim
            DO m = 1, npart
               x(m,idim,1) = xnodes(idim,inode(m))
            END DO
         END DO

         !--- position of other corner nodes
         DO idim = 1, ndim
            icornr = 1 + 2**(idim-1)
            DO m = 1, npart
               inode(m)    = ncnode(icornr,icell(m))
               x(m,idim,2) = xnodes(idim,inode(m))
            END DO
         END DO

         !--- multiplicators in ndim directions
         DO idim = 1, ndim
            DO m = 1, npart
               x1 = x(m,idim,1)
               x2 = x(m,idim,2)
               fac1 = (point(m,idim) - x1)/MAX(x2-x1,tiny)
               fac1 = MIN(one ,fac1)
               fac1 = MAX(zero,fac1)
               facx(m,idim,0) = one - fac1
               facx(m,idim,1) = fac1
            END DO
         END DO

         !--- loop over corners
         DO icornr = 1, ncornr
          
            DO m = 1, npart
               inode(m)  = ncnode(icornr,icell(m))
               factor(m) = one
            END DO

            idum = icornr - 1

            DO idim = ndim,1,-1
               jdim  = 2**(idim-1)
               iside = idum/jdim
               DO m = 1, npart
                  factor(m) = factor(m)*facx(m,idim,iside)
               END DO
               idum = idum - iside*jdim
            END DO

            !--- add to dependent property array
            DO iprop = 1, nprop
               DO m = 1, npart
                  prop(m,iprop) = prop(m,iprop) +  &
                                  factor(m)*protab(iprop,inode(m))
               END DO
            END DO

         END DO

        !--- exit; interpolation finished
        GOTO 9999

      ELSE
      !--------------------------------------------
      !  some cells have child cells

         !--- loop over all particles
         DO m = 1, npart

            !--- check if current particle has child cells
            IF (nchild(icell(m)) >= 1) THEN

      !------
      !  determine in which child cell the point lies
      !  start with first child cell
      !-----------------------------

               Found = .TRUE.
               jcell = nchild(icell(m))

               !--- position of first corner node
               inode(m) = ncnode(1,jcell)
               DO idim = 1, ndim
                  x(m,idim,1) = xnodes(idim,inode(m))
               END DO

               !--- position of other corner nodes
               DO idim = 1, ndim
                  icornr      = 1 + 2**(idim-1)
                  inode(m)    = ncnode(icornr,jcell)
                  x(m,idim,2) = xnodes(idim,inode(m))
                  xp = point(m,idim)
                  Found = Found .AND. &
                       (x(m,idim,1).LE.xp+small .AND. xp-small.LE.x(m,idim,2))
               END DO

               !--- point not in first child cell: must be in second child cell
               IF (.NOT.Found) jcell = jcell + 1

               icell(m) = jcell

            END IF

         END DO

      END IF

      !--- return to check for child cells
      GOTO 200

 9999 CONTINUE

      END SUBROUTINE lookupv


      END MODULE fllookup_module
